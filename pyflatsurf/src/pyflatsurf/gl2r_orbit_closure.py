# -*- coding: utf-8 -*-
r"""
GL(2,R)-orbit closure of translation surfaces.

.. TODO::

    - Comparison of renf_elem with Python int not supported (but seem to work through
      the RealEmbeddedNumberField)

    - Removing fake zeros (in sage-flatsurf?), this is a bit delicate because of
      potential edges that join a fake zero to itself. Best strategy is probably
      to allow non-convex polygon and be able to triangulate them in a second time.

    - the method name ``fromEdge`` is completely misleading
      (how do we guess that it build a vector, how do we guess that it takes a half-edge as input)

    - Theorem 1.9 of Alex Wright: the field of definition is contained in the field generated by
      the ratio of circumferences. We should provide a method, .reset_field_of_definition or
      something similar

    - implement complete periodicity detection
      https://github.com/flatsurf/intervalxt/issues/86

TESTS:

    ((-a^4 + 9/2*a^2 - 5/2 ~ 2.5244587), (1/2*a^3 - 1*a ~ 0.34794774))
"""
######################################################################
#  This file is part of flatsurf.
#
#        Copyright (C) 2019-2020 Julian RÃ¼th
#                      2020      Vincent Delecroix
#
#  flatsurf is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  flatsurf is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with flatsurf. If not, see <https://www.gnu.org/licenses/>.
######################################################################

import cppyy
from pyeantic import RealEmbeddedNumberField
import pyflatsurf
from pyflatsurf import flatsurf

# TODO: move into flatsurf
Vertex = cppyy.gbl.flatsurf.Vertex

from sage.all import VectorSpace, matrix, identity_matrix, ZZ, QQ, Unknown

def proj(v):
    x,y = v
    if y:
        return v/y
    if x:
        return v/x
    raise ValueError

class Decomposition:
    def __init__(self, gl2rorbit, decomposition, u):
        self.u = u
        self.orbit = gl2rorbit
        self.decomposition = decomposition

    def num_cylinders_minimals_undetermined(self):
        ncyl = 0
        nmin = 0
        nund = 0
        for comp in self.decomposition.components():
            if comp.cylinder() == True:
                assert comp.withoutPeriodicTrajectory() == False
                ncyl += 1
            elif comp.cylinder() == False:
                assert comp.withoutPeriodicTrajectory() == True
                nmin += 1
            else:
                nund += 1
        return (ncyl, nmin, nund)

    def decompose(self, limit=-1):
        r"""
        Split the components into more pieces.
        """
        flatsurf.decomposeFlowDecomposition(self.decomposition, limit)

    def __repr__(self):
        ncyl, nmin, nund = self.num_cylinders_minimals_undetermined()
        return "Flow decomposition with %d cylinders, %d minimal components and %d undetermined components" % (ncyl, nmin, nund)

    def is_completely_periodic(self):
        r"""
        Return whether this flow decomposition consists only of cylinders.
        """
        ncyl, nmin, nund = self.num_cylinders_minimals_undetermined()
        if nmin:
            return False
        elif nund:
            return Unknown
        else:
            return True

    def _spanning_tree_decomposition(self, sc_index, sc_comp):
        r"""
        Return

        - a list of indices of edges that form a basis
        - a matrix projection to the basis (modulo the face relations)
        """
        components = [c for c in self.decomposition.components()]

        n = len(sc_index)
        assert n % 2 == 0
        n //= 2

        for p in components[0].perimeter():
            break
        root = p.saddleConnection()
        t = {0: None} # face -> half edge to take to go to the root
        todo = [0]
        edges = []  # store edges in topological order to perform Gauss reduction
        while todo:
            i = todo.pop()
            c = components[i]
            for sc in c.perimeter():
                sc1 = -sc.saddleConnection()
                j = sc_comp[sc1]
                if j not in t:
                    t[j] = sc1
                    todo.append(j)
                    edges.append(sc1)

        # gauss reduction
        spanning_set = set(range(n))
        proj = identity_matrix(ZZ, n)
        edges.reverse()
        for sc1 in edges:
            i1 = sc_index[sc1]
            if i1 < 0:
                s1 = -1
                i1 = -i1-1
            else:
                s1 = 1
            comp = components[sc_comp[sc1]]
            proj[i1] = 0
            for p in comp.perimeter():
                sc = p.saddleConnection()
                if sc == sc1:
                    continue
                j = sc_index[sc]
                if j < 0:
                    s = -1
                    j = -j-1
                else:
                    s = 1
                proj[i1] = - s1 * s * proj[j]

            spanning_set.remove(i1)
            for j in range(n):
                assert proj[j,i1] == 0

        return (t, sorted(spanning_set), proj)

    def kontsevich_zorich_cocycle(self):
        r"""
        Base change for this flow decomposition.
        """
        components = [c for c in self.decomposition.components()]
        sc_pos = []
        sc_comp = {}
        sc_index = {}
        n = 0
        for i,comp in enumerate(components):
            for p in comp.perimeter():
                sc = p.saddleConnection()
                sc_comp[sc] = i
                if sc not in sc_index:
                    sc_index[sc] = n
                    sc_pos.append(sc)
                    sc_index[-sc] = -n-1
                    n += 1

        t, spanning_set, proj = self._spanning_tree_decomposition(sc_index, sc_comp)
        assert proj.rank() == len(spanning_set) == n - len(components) + 1, self.u
        proj = proj.transpose()
        proj = matrix(ZZ, [r for r in proj.rows() if not r.is_zero()])
        assert proj.nrows() == self.orbit.proj.nrows(), self.u

        # Write the base change V^*(T') -> V^*(T) relative to our bases
        A = matrix(ZZ, self.orbit.d)
        for i, sc in enumerate(spanning_set):
            sc = sc_pos[sc]
            c = sc.chain()
            v = [0] * self.orbit.d
            for edge in self.orbit.surface.edges():
                A[i] += ZZ(str(c[edge])) * self.orbit.proj.column(edge.index())
        assert A.det().is_unit()
        return A, sc_index, proj

    def is_parabolic(self):
        r"""
        Return whether this decomposition is completely periodic with cylinder with
        commensurable moduli.

        .. NOTE::

            This function triggers a call to ``kontsevich_zorich_cocycle``
            which might be a little bit expensive.
        """
        cp = self.is_completely_periodic()
        if cp is not True:
            return cp

        A, sc_index, proj = self.kontsevich_zorich_cocycle()
        m = None
        for comp in self.decomposition.components():
            _,_,_,mm,_ = self.circumference_height_holonomy_module_area(comp, sc_index, proj)
            if m is None:
                m = mm
            elif not (mm / m).is_rational():
                return False
        return True

    def cylinder_diagram(self):
        r"""
        Transform a decomposition into a cylinder diagram (from ``surface_dynamics``).
        """
        if not self.is_completely_periodic():
            raise ValueError("not a completely periodic direction")

        indices = {}
        cyls = []
        k = 0
        for c in self.decomposition.components():
            contour = [p for p in c.perimeter()]
            ibot = 0
            assert not contour[ibot].vertical()
            itop = 1
            while contour[itop].vertical():
                itop += 1
            assert all(contour[i].vertical() for i in range(itop+1, len(contour)))
            bot = []
            for i in range(ibot+1, itop):
                if contour[i] not in indices:
                    indices[contour[i]] = k
                    indices[-contour[i]] = k
                    k += 1
                bot.append(indices[contour[i]])
            top = []
            for i in range(itop+1, len(contour)):
                if contour[i] not in indices:
                    indices[contour[i]] = k
                    indices[-contour[i]] = k
                    k += 1
                top.append(indices[contour[i]])
            cyls.append((bot, top))

        from surface_dynamics import CylinderDiagram
        return CylinderDiagram(cyls)


    def circumference_height_holonomy_module_area(self, component, sc_index, proj):
        r"""
        Return the circumference of the ``i``-th cylinder in the coordinate of
        the original surface.

        EXAMPLES::

            sage: import flatsurf as sage_flatsurf

        Calta-McMullen Veech surfaces in H(2) are completely periodic with 2 cylinder in
        every saddle connection direction::

            sage: S = sage_flatsurf.translation_surfaces.mcmullen_genus2_prototype(2,1,0,0)
            sage: O = GL2ROrbitClosure(S)
            sage: print('%-16s %-16s %-16s %-16s' % ('direction', 'circum. ratio', 'modules ratio', 'area'))
            sage: for (u, decomp) in O.decompositions(3):
            ....:     assert len(decomp.components) == 2
            ....:     assert decomp.is_completely_periodic()
            ....:     c0,h0,m0,a0 = decomp.circumference_holonomy_module_area(0)
            ....:     c1,h1,m1,a1 = decomp.circumference_holonomy_module_area(1)
            ....:     if h0[0]:
            ....:         r = h1[0] / h0[0]
            ....:     else:
            ....:         r = h1[1] / h0[1]
            ....:     if r < 1: r = 1/r
            ....:     mr = m0/m1 if m1 > m0 else m1/m0
            ....:     print('%-16s %-16s %-16s %-16s' %(u, r, mr, (a0,a1)))
            sage: print('%-16s %-16s %-16s' % ('direction', 'ratio', 'areas'))
            direction        circum. ratio    modules ratio    area            
            (1, 1)           a                1/2              (2, 2)          
            (-a + 2, 1)      a                1/2              (2, 2)          
            (1, 0)           a                1/2              (2, 2)          
            (a, 1)           a                1/2              (2, 2)          
            (2, 1)           a + 1            1                (a + 2, -a + 2) 
            (0, 1)           a + 1            1                (-a + 2, a + 2) 
            (-1, 1)          a                1/2              (2, 2)          
            (a - 2, 1)       a                1/2              (2, 2)          
            (-a, 1)          a                1/2              (2, 2)          
            (-2, 1)          a + 1            1                (a + 2, -a + 2) 
            (1/2*a - 1, 1)   a                1/2              (2, 2)          
            (a - 4, 1)       a                1/2              (2, 2)          
            (-1/2*a + 1, 1)  a                1/2              (2, 2)          
            (-a + 4, 1)      a                1/2              (2, 2)          

            sage: S = sage_flatsurf.translation_surfaces.mcmullen_genus2_prototype(4,1,0,1)
            sage: O = GL2ROrbitClosure(S)
            sage: print('%-16s %-16s %-16s %-16s' % ('direction', 'circum. ratio', 'modules ratio', 'area'))
            sage: for (u, decomp) in O.decompositions(3):
            ....:     assert len(decomp.components) == 2
            ....:     assert decomp.is_completely_periodic()
            ....:     c0,h0,m0,a0 = decomp.circumference_holonomy_module_area(0)
            ....:     c1,h1,m1,a1 = decomp.circumference_holonomy_module_area(1)
            ....:     if h0[0]:
            ....:         r = h1[0] / h0[0]
            ....:     else:
            ....:         r = h1[1] / h0[1]
            ....:     if r < 1: r = 1/r
            ....:     mr = m0/m1 if m1 > m0 else m1/m0
            ....:     print('%-16s %-16s %-16s %-16s' %(u, r, mr, (a0,a1)))
            direction        circum. ratio    modules ratio    area
            (1, 0)           a - 1            1/4              (a + 4, 4)
            (a, 1)           1/2*a            1                (4, a + 4)
            (0, 1)           a + 1            1/2              (-a + 4, 2*a + 4)
            (-a, 1)          1/2*a            1                (4, a + 4)
            (a - 4, 1)       1/2*a            1                (a + 4, 4)
            (1/2*a - 2, 1)   a - 1            1/4              (4, a + 4)
            (-a + 4, 1)      1/2*a            1                (a + 4, 4)
            (-1/2*a + 2, 1)  a - 1            1/4              (a + 4, 4)
        """
        A, sc_index, proj = self.kontsevich_zorich_cocycle()
        perimeters = [p for p in component.perimeter()]
        per = perimeters[0]
        assert not per.vertical()
        sc = per.saddleConnection()
        i = sc_index[sc]
        if i < 0:
            s = -1
            i = -i-1
        else:
            s = 1
        v = s * proj.column(i)
        circumference = -A.solve_right(v)
        hol = self.orbit.holonomy_dual(circumference)

        u = sc.vector()
        u = self.orbit.V2((self.orbit.Ksage_constructor(u.x()), self.orbit.Ksage_constructor(u.y())))
        area = u[0] * hol[1] - u[1] * hol[0]
        assert area > 0

        height = -self.u[1] * u[0] + self.u[0] * u[1]
        module = area / (hol[0]**2 + hol[1]**2)

        return (circumference, height, hol, module, area)

    def cylinder_deformation_subspace(self):
        r"""
        Return a subspace included in the tangent space to the GL(2,R)-orbit closure.

        From A. Wright cylinder deformation Theorem.
        """
        v = self.orbit.V()
        modules = []
        vcyls = []
        A, sc_index, proj = self.kontsevich_zorich_cocycle()
        for comp in self.decomposition.components():
            if comp.cylinder() == False:
                continue
            elif comp.cylinder() == True:
                circ, height, hol, mod, area = self.circumference_height_holonomy_module_area(comp, sc_index, proj)
                vcyls.append(height * circ)
                modules.append(mod)
            else:
                return self.orbit.V.subspace([])

        # irrationally related cylinders can be twisted independently
        vectors = []
        if self.orbit.Ksage is QQ:
            vectors.append(sum(vcyls))
        else:
            ncyls = len(vcyls)
            M = matrix([mod.vector() for mod in modules])
            relations = M.left_kernel().matrix()
            for t in relations.right_kernel().basis():
                vectors.append(sum(t[i] / modules[i] * vcyls[i] for i in range(ncyls)))

        return self.orbit.V.subspace(vectors)

class GL2ROrbitClosure:
    r"""
    Approximation to the tangent space of a GL(2,R)-orbit closure of a
    translation surface.

    EXAMPLES::

        sage: import pyflatsurf
        sage: import flatsurf as sage_flatsurf
        sage: T = sage_flatsurf.polygons.triangle(3, 3, 5)
        sage: S = sage_flatsurf.similarity_surfaces.billiard(T)
        sage: S = S.minimal_cover(cover_type="translation")
        sage: O = GL2ROrbitClosure(S)
        sage: O
        GL(2,R)-orbit closure of dimension at least 2 in H_5(4, 2^2) (ambient dimension 12)

    TESTS::

        sage: from itertools import product
        sage: for a in range(1,5):
        ....:     for b in range(a, 5):
        ....:         for c in range(b, 5):
        ....:             if gcd([a, b, c]) != 1:
        ....:                 continue
        ....:             T = sage_flatsurf.polygons.triangle(a, b, c)
        ....:             S = sage_flatsurf.similarity_surfaces.billiard(T)
        ....:             S = S.minimal_cover(cover_type="translation")
        ....:             O = GL2ROrbitClosure(S)
        ....:             print(a, b, c, O)
        1 1 1 GL(2,R)-orbit closure of dimension at least 2 in H_1(0^3) (ambient dimension 4)
        1 1 2 GL(2,R)-orbit closure of dimension at least 2 in H_1(0^4) (ambient dimension 5)
        1 1 3 GL(2,R)-orbit closure of dimension at least 2 in H_2(2, 0^2) (ambient dimension 6)
        1 1 4 GL(2,R)-orbit closure of dimension at least 2 in H_2(1^2, 0^2) (ambient dimension 7)
        1 2 2 GL(2,R)-orbit closure of dimension at least 2 in H_2(1^2, 0) (ambient dimension 6)
        1 2 3 GL(2,R)-orbit closure of dimension at least 2 in H_1(0^6) (ambient dimension 7)
        1 2 4 GL(2,R)-orbit closure of dimension at least 2 in H_3(3, 1, 0) (ambient dimension 8)
        1 3 3 GL(2,R)-orbit closure of dimension at least 2 in H_3(2^2, 0) (ambient dimension 8)
        1 3 4 GL(2,R)-orbit closure of dimension at least 2 in H_2(2, 0^5) (ambient dimension 9)
        1 4 4 GL(2,R)-orbit closure of dimension at least 2 in H_4(3^2, 0) (ambient dimension 10)
        2 2 3 GL(2,R)-orbit closure of dimension at least 2 in H_3(2, 1^2) (ambient dimension 8)
        2 3 3 GL(2,R)-orbit closure of dimension at least 2 in H_3(2^2, 0^2) (ambient dimension 9)
        2 3 4 GL(2,R)-orbit closure of dimension at least 2 in H_3(3, 1, 0^3) (ambient dimension 10)
        3 3 4 GL(2,R)-orbit closure of dimension at least 2 in H_4(2^2, 1^2) (ambient dimension 11)
        3 4 4 GL(2,R)-orbit closure of dimension at least 2 in H_5(3^2, 2) (ambient dimension 12)
    """
    def __init__(self, surface):
        self.surface = surface = pyflatsurf.Surface(surface)
        self.n = surface.size()
            
        self.half_edge_to_face = {}
        self.half_edge_to_edge = {}
        for e in surface.edges():
            h1 = e.positive()
            self.half_edge_to_edge[h1] = e
            if h1 not in self.half_edge_to_face:
                h2 = surface.nextInFace(h1)
                h3 = surface.nextInFace(h2)
                h = min([h1, h2, h3])
                self.half_edge_to_face[h1] = h
                self.half_edge_to_face[h2] = h
                self.half_edge_to_face[h3] = h

            h1 = e.negative()
            self.half_edge_to_edge[h1] = e
            if h1 not in self.half_edge_to_face:
                h2 = surface.nextInFace(h1)
                h3 = surface.nextInFace(h2)
                h = min([h1, h2, h3])
                self.half_edge_to_face[h1] = h
                self.half_edge_to_face[h2] = h
                self.half_edge_to_face[h3] = h

        # spanning set of edges and projection matrix
        t, m = self._spanning_tree()
        assert set(t.keys()) == set(self.half_edge_to_face.values())
        self.spanning_set = []
        v = set(t.values())
        for e in self.surface.edges():
            if e.positive() not in v and e.negative() not in v:
                self.spanning_set.append(e)
        self.d = len(self.spanning_set)
        assert 3*self.d - 3 == self.n
        assert m.rank() == self.d
        m = m.transpose()
        self.proj = matrix(ZZ, [r for r in m.rows() if not r.is_zero()])

        self.Omega = self._intersection_matrix(t, self.spanning_set)

        # ambient vector space and the tangent subspace
        # NOTE:
        # Sage number field: self.K.number_field
        # eantic number field: self.K.renf
        x = surface.fromEdge(surface.halfEdges()[0]).x()
        if isinstance(x, cppyy.gbl.mpq_class):
            self.Ksage = QQ
            self.Ksage_constructor = lambda x: QQ(str(x))
        else:
            k = x.parent()
            self.K = RealEmbeddedNumberField(k)
            self.Ksage = self.K.number_field
            self.Ksage_constructor = lambda x: self.Ksage(self.K(x))

        self.V = VectorSpace(self.Ksage, self.d)
        self.V2 = VectorSpace(self.Ksage, 2)

        self.H = matrix(self.Ksage, self.d, 2)
        for i in range(self.d):
            s = self.surface.fromEdge(self.spanning_set[i].positive())
            self.H[i] = self.V2((self.Ksage_constructor(s.x()), self.Ksage_constructor(s.y())))
        self.Hdual = self.Omega * self.H
        self.U = self.H.transpose()
        # NOTE: if too slow use echelonize
        # self.U.echelonize()
        self.U = self.U.row_space()

    def __repr__(self):
        return "GL(2,R)-orbit closure of dimension at least %d in %s (ambient dimension %d)" % (self.U.dimension(), self.stratum(), self.d)

    def holonomy(self, v):
        r"""
        Return the holonomy of ``v`` (with respect to the basis)
        """
        return self.V(v) * self.H

    def holonomy_dual(self, v):
        return self.V(v) * self.Hdual

    def absolute_homology(self):
        vert_index = {v:i for i,v in enumerate(self.surface.vertices())}
        m = len(vert_index)
        if m == 1:
            return self.V
        rows = []
        for e in self.spanning_set:
            r = [0] * m
            i = vert_index[Vertex.target(e.positive(), self.surface)]
            j = vert_index[Vertex.source(e.positive(), self.surface)]
            if i != j:
                r[i] = 1
                r[j] = -1
            rows.append(r)
        return matrix(rows).left_kernel()

    def absolute_dimension(self):
        r"""
        EXAMPLES::

            sage: T = sage_flatsurf.polygons.triangle(1,3,4)  # Veech octagon
            sage: S = sage_flatsurf.similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover("translation")
            sage: O = GL2ROrbitClosure(S)
            sage: O.absolute_dimension()
            2

        The triangular billiard (5,6,7) belongs to the canonical double cover of
        the stratum Q(5,3,0^3) in genus 3. The orbit is dense and we can check
        that the absolute dimension is indeed `6 = 2 rank`::

            sage: T = sage_flatsurf.polygons.triangle(5,6,7)
            sage: S = sage_flatsurf.similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover("translation")
            sage: O = GL2ROrbitClosure(S)
            2
            sage: for d in O.decompositions(5):
            ....:     d.decompose()
            ....:     O.update_tangent_space_from_flow_decomposition(d)
            ....:     if O.U.dimension() == 9:
            ....:         break
            sage: O.absolute_dimension()
            6
        """
        return (self.absolute_homology().matrix() * self.U.matrix().transpose()).rank()

    # TODO: how do we do that!?
    def stratum(self):
        r"""
        Return the ambient stratum.

        EXAMPLES::

            sage: import pyflatsurf
            sage: import flatsurf as sage_flatsurf
            sage: T = sage_flatsurf.polygons.triangle(1, 2, 4)
            sage: S = sage_flatsurf.similarity_surfaces.billiard(T)
            sage: S = S.minimal_cover(cover_type="translation")
            sage: O = GL2ROrbitClosure(S)
            sage: O.stratum()
            H(3, 1, 0)
        """
        sings = [self.surface.angle(v)-1 for v in self.surface.vertices()]
        from surface_dynamics import AbelianStratum
        return AbelianStratum(*sings)

    def _spanning_tree(self, root=None):
        r"""
        Return

        - a list of indices of edges that form a basis
        - a matrix projection to the basis (modulo the triangle relations)
        """
        if root is None:
            root = next(iter(self.surface.edges())).positive()

        root = self.half_edge_to_face[root]
        t = {root: None} # face -> half edge to take to go to the root
        todo = [root]
        edges = []  # store edges in topological order to perform Gauss reduction
        while todo:
            f = todo.pop()
            for _ in range(3):
                f1 = -f
                g = self.half_edge_to_face[f1]
                if g not in t:
                    t[g] = f1
                    todo.append(g)
                    edges.append(f1)

                f = self.surface.nextInFace(f)

        # gauss reduction
        proj = identity_matrix(ZZ, self.n)
        edges.reverse()
        for f1 in edges:
            v = [0] * self.n
            f2 = self.surface.nextInFace(f1)
            f3 = self.surface.nextInFace(f2)
            assert self.surface.nextInFace(f3) == f1

            i1 = f1.index()
            s1 = -1 if i1%2 else 1
            i2 = f2.index()
            s2 = -1 if i2%2 else 1
            i3 = f3.index()
            s3 = -1 if i3%2 else 1
            i1 = self.half_edge_to_edge[f1].index()
            i2 = self.half_edge_to_edge[f2].index()
            i3 = self.half_edge_to_edge[f3].index()
            proj[i1] = -s1*(s2*proj[i2] + s3*proj[i3])
            for j in range(self.n):
                assert proj[j,i1] == 0

        return (t, proj)

    def _intersection_matrix(self, t, spanning_set):
        r"""
        Given a spanning tree, compute the associated intersection matrix.

        It can be used to compute holonomies. (we can be off by a - sign)
        """
        d = len(spanning_set)
        h = spanning_set[0].positive()
        all_edges = set([e.positive() for e in spanning_set])
        all_edges.update([e.negative() for e in spanning_set])
        contour = []
        contour_inv = {}   # half edge -> position in contour
        while h not in contour_inv:
            contour_inv[h] = len(contour)
            contour.append(h)
            h = self.surface.nextAtVertex(-h)
            while h not in all_edges:
                h = self.surface.nextAtVertex(h)

        assert len(contour) == len(all_edges)

        # two curves intersect when their relative position in the contour
        # are x y x y or y x y x
        Omega = matrix(ZZ, d)
        for i in range(len(spanning_set)):
            ei = spanning_set[i]
            pi1 = contour_inv[ei.positive()]
            pi2 = contour_inv[ei.negative()]
            if pi1 > pi2:
                si = -1
                pi1, pi2 = pi2, pi1
            else:
                si = 1
            for j in range(i+1, len(spanning_set)):
                ej = spanning_set[j]
                pj1 = contour_inv[ej.positive()]
                pj2 = contour_inv[ej.negative()]
                if pj1 > pj2:
                    sj = -1
                    pj1, pj2 = pj2, pj1
                else:
                    sj = 1

                # pj1 pj2 pi1 pi2: pj2 < pi1
                # pi1 pi2 pj1 pj2: pi2 < pj1
                # pi1 pj1 pj2 pi2: pi1 < pj1 and pj2 < pi2
                # pj1 pi1 pi2 pj2: pj1 < pi1 and pi2 < pj2
                if (pj2 < pi1) or (pi2 < pj1) or \
                   (pj1 > pi1 and pj2 < pi2) or \
                   (pj1 < pi1 and pj2 > pi2):
                    # no intersection
                    continue

                if pi1 < pj1 < pi2:
                    # one sign
                    Omega[i,j] = si * sj
                else:
                    # other sign
                    assert pi1 < pj2 < pi2, (pi1, pi2, pj1, pj2)
                    Omega[i,j] = -si*sj
                Omega[j,i] = - Omega[i,j]
        return Omega

    def boundaries(self):
        r"""
        Return the list of boundaries (ie sum of edges around a triangular face).

        TESTS::

            sage: from itertools import product
            sage: for a in range(1,5):
            ....:     for b in range(a, 5):
            ....:         for c in range(b, 5):
            ....:             if gcd([a, b, c]) != 1 or (a,b,c) == (1,1,2):
            ....:                 continue
            ....:             T = sage_flatsurf.polygons.triangle(a, b, c)
            ....:             S = sage_flatsurf.similarity_surfaces.billiard(T)
            ....:             S = S.minimal_cover(cover_type="translation")
            ....:             O = GL2ROrbitClosure(S)
            ....:             for b in O.boundaries():
            ....:                 assert (O.proj * b).is_zero()
        """
        B = []
        for f1,F in self.half_edge_to_face.items():
            if f1 != F:
                continue
            f2 = self.surface.nextInFace(f1)
            f3 = self.surface.nextInFace(f2)
            i1 = f1.index()
            s1 = -1 if i1%2 else 1
            i2 = f2.index()
            s2 = -1 if i2%2 else 1
            i3 = f3.index()
            s3 = -1 if i3%2 else 1
            i1 = self.half_edge_to_edge[f1].index()
            i2 = self.half_edge_to_edge[f2].index()
            i3 = self.half_edge_to_edge[f3].index()
            v = [0] * self.n
            v[i1] = 1
            v[i2] = s1 * s2
            v[i3] = s1 * s3
            B.append(vector(ZZ, v))
            B[-1].set_immutable()

        return B

    def saddle_connection_directions(self, bound):
        # NOTE: for now there is a lot of duplicates!!
        explored = set()
        for connection in self.surface.saddle_connections(flatsurf.Bound(bound, 0)):
            v = connection.vector()
            if v.y() == int(0):
                u = self.V2((1, 0))
            else:
                u = self.V2((self.Ksage_constructor(v.x() / v.y()), 1))
            u.set_immutable()
            if u in explored:
                continue
            else:
                explored.add(u)
            yield v

    def decomposition(self, v, limit=-1):
        decomposition = flatsurf.makeFlowDecomposition(self.surface, v)
        u = self.V2((self.Ksage_constructor(v.x()), self.Ksage_constructor(v.y())))
        return Decomposition(self, decomposition, u)

    def decompositions(self, bound, limit=-1):
        # NOTE: for now there is a lot of duplicates!!
        explored = set()
        for connection in self.surface.saddle_connections(flatsurf.Bound(bound, 0)):
            v = connection.vector()
            if v.y() == int(0):
                u = self.V2((1, 0))
            else:
                u = self.V2((self.Ksage_constructor(v.x() / v.y()), 1))
            u.set_immutable()
            if u in explored:
                continue
            else:
                explored.add(u)
            yield self.decomposition(v, limit)

    def completely_periodic_directions(self, bound):
        r"""
        Iterator through completely directions
        """
        for decomp in self.decompositions(bound):
            if decomp.is_completely_periodic():
                yield decomp

    def update_tangent_space_from_flow_decomposition(self, decomposition, verbose=False):
        r"""
        There are several kind of things that we can do

        - cylinder with independent moduli can be twisted independently
        - cylinder deformation

        EXAMPLES:

        """
        A = self.U.ambient_vector_space()
        ambient_dim = A.dimension()
        cur_dim = self.U.dimension()
        if cur_dim == A.dimension():
            if verbose:
                print("full stratum")
            return
        self.U += decomposition.cylinder_deformation_subspace()
        new_dim = self.U.dimension()
        if verbose and new_dim > cur_dim :
            print("increase in dimension: {} in ambient dimension {}".format(new_dim, ambient_dim))
